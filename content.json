{"pages":[{"title":"","text":"","link":"/links.html"},{"title":"","text":"关于我…","link":"/about.html"}],"posts":[{"title":"JMeter如何使用Java编写测试用例-AbstractJavaSamplerClient","text":"概述在 JMeter 中， 支持我们可以编写 Java 代码来发送请求， 用来提高拓展性， 如下图所示 实践要成为 JMeter 可识别的脚本， 该脚本需要继承 AbstractJavaSamplerClient 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HttpBinPostCase extends AbstractJavaSamplerClient { HttpClient httpClient; String url; @Override public void setupTest(JavaSamplerContext context) { httpClient = HttpClients.createDefault(); url = context.getParameter(&quot;url&quot;); } @SneakyThrows @Override public SampleResult runTest(JavaSamplerContext context) { HttpPost httpPost= new HttpPost(url); SampleResult sampleResult=new SampleResult(); sampleResult.setSampleLabel(&quot;httpbin post case&quot;); sampleResult.sampleStart(); HttpResponse result = httpClient.execute(httpPost); String entity= EntityUtils.toString(result.getEntity()); if (result.getStatusLine().getStatusCode()==200){ sampleResult.setSuccessful(true); sampleResult.setResponseCodeOK(); }else { sampleResult.setSuccessful(false); sampleResult.setResponseCode(String.valueOf(result.getStatusLine().getStatusCode())); } sampleResult.setResponseData(entity, &quot;utf-8&quot;); // 在这里存储API 返回值 JMeterSampleResultMap.result.put(context.getJMeterVariables().getThreadName(), entity); return sampleResult; } @Override public void teardownTest(JavaSamplerContext context) { super.teardownTest(context); } @Override public Arguments getDefaultParameters() { Arguments arguments = new Arguments(); arguments.addArgument(&quot;url&quot;, &quot;https://httpbin.org/post&quot;); return arguments; }} 然后将该项目打包成一个 Jar 包， 再引入 JMeter 中即可","link":"/2022/03/22/JMeter%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Java%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-AbstractJavaSamplerClient/"},{"title":"JMeter如何管理测试数据","text":"CSV第一种最简单的也最常见的是通过 csv 来传入测试数据接下来我们测试下 CSV 取值 Mysql 数据库需要将 Mysql Driver Lib 下载保存的 lib 文件夹 那么如何遍历数据库中的每一个值呢？ 使用 foreach 遍历 先算出数据库有多少数据， 然后用 for 循环遍历 foreach：新建一个 FoeEach 的 controller Input variable： 指的是你之前设置的变量名 Output variable： 指的是你之后从这个变量集合中取出来的单个变量的名字","link":"/2022/03/21/JMeter%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"},{"title":"JPA使用记录-如何批量新增数据","text":"概述实现基本功能： 批量增加， 批量更新， insert 和 update 方法 代码首先需要自己定义一个基础接口类 12345678// 告诉 spring 不要实例化这个对象@NoRepositoryBeanpublic interface BaseJapRepository&lt;T,ID&gt; extends JpaRepository&lt;T, ID&gt;, JpaSpecificationExecutor&lt;T&gt; { &lt;S extends T&gt; List&lt;S&gt; addAll(Iterable&lt;S&gt; entities); &lt;S extends T&gt; List&lt;S&gt; updateAll(Iterable&lt;S&gt; entities); &lt;S extends T&gt; S update(S entity); &lt;S extends T&gt; S insert(S entity);} 然后自定义一个实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.chancetop.atp.repositories;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.jpa.repository.support.JpaEntityInformation;import org.springframework.data.jpa.repository.support.SimpleJpaRepository;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import java.util.ArrayList;import java.util.List;public class CustomerJpaRepositoryImpl&lt;T, ID&gt; extends SimpleJpaRepository&lt;T, ID&gt; implements BaseJapRepository&lt;T, ID&gt; { private static Logger logger = LoggerFactory.getLogger(CustomerJpaRepositoryImpl.class); private EntityManager entityManager; private JpaEntityInformation&lt;T, ?&gt; entityInformation; public CustomerJpaRepositoryImpl(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager) { super(entityInformation, entityManager); this.entityManager = entityManager; this.entityInformation = entityInformation; } public CustomerJpaRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager em) { super(domainClass, em); this.entityManager = em; } @Transactional(rollbackFor = Exception.class) @Override public &lt;S extends T&gt; List&lt;S&gt; addAll(Iterable&lt;S&gt; entities) { List&lt;S&gt; result = new ArrayList&lt;&gt;(); entities.forEach(item -&gt; { entityManager.persist(item); result.add(item); }); entityManager.flush(); entityManager.clear(); return result; } @Transactional(rollbackFor = Exception.class) public &lt;S extends T&gt; List&lt;S&gt; updateAll(Iterable&lt;S&gt; entities) { List&lt;S&gt; result = new ArrayList&lt;&gt;(); entities.forEach(item -&gt; { this.entityManager.merge(item); result.add(item); }); entityManager.flush(); entityManager.clear(); return result; } @Transactional(rollbackFor = Exception.class) @Override public &lt;S extends T&gt; S update(S entity) { entityManager.merge(entity); // merge 是 update return entity; } @Transactional(rollbackFor = Exception.class) @Override public &lt;S extends T&gt; S insert(S entity) { entityManager.persist(entity); // persist 是插入 return entity; }} 我们要把这个实现类作为一个 JPA 的实现类, 只需要在启动类上面定义一下即可 12345678@SpringBootApplication// 定义 JPA 类@EnableJpaRepositories(repositoryBaseClass= CustomerJpaRepositoryImpl.class)public class AtpApplication { public static void main(String[] args) { SpringApplication.run(AtpApplication.class, args); }} 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.chancetop.atp.entites;import com.chancetop.atp.repositories.ProjectRepository;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.ArrayList;import java.util.List;@SpringBootTestpublic class ProjectTest { private ProjectRepository projectRepository; @Autowired public ProjectTest(ProjectRepository projectRepository){ this.projectRepository = projectRepository; } @Test public void testSave(){ Project project = new Project(); project.setProjectName(&quot;test-project&quot;); project.setProjectOwner(&quot;jackson&quot;); project.setProjectDesc(&quot;this is test project&quot;); projectRepository.save(project); } /** * 测试批量添加 */ @Test public void testAddAll(){ List&lt;Project&gt; projects = new ArrayList&lt;&gt;(); Project project = new Project(); project.setProjectName(&quot;test-project&quot;); project.setProjectOwner(&quot;jackson&quot;); project.setProjectDesc(&quot;this is test project&quot;); Project project2 = new Project(); project2.setProjectName(&quot;test-project-2&quot;); project2.setProjectOwner(&quot;jackson2&quot;); project2.setProjectDesc(&quot;this is test project2&quot;); projects.add(project); projects.add(project2); projectRepository.addAll(projects); } @Test public void testUpdateAll(){ List&lt;Project&gt; projects = projectRepository.findAll(); int i = 0; for (Project project : projects) { project.setProjectName(&quot;aaaaa&quot; + i); i++; } projectRepository.updateAll(projects); }} 总结 首先还是要先定义数据库表, 然后再自己编写类， 应该设置 ddl-auto: none 如果要修改数据库字段， 还是需要通过 SQL 修改比较安全 最后就是复杂的语句， 需要通过 @Query(&lt;SQL&gt;) 来写。 目前来看，比 Mybatis 更清晰。 待深入再了解了解。","link":"/2022/03/22/JPA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE/"},{"title":"JPA使用记录-开发流程","text":"概述使用流程： 执行 SQL 脚本 根据 SQL 脚本编写 Entity 执行测试 编写 SQL 脚本假设我们要创建一个表， 最好的方式是不要通过代码直接创建表，首先不安全，其次容易把数据都删了， 最安全的操作还是数据库操作一次， 代码修改一次。创建一个表: 1234567891011CREATE TABLE IF NOT EXISTS `t_user` ( `user_id` varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'User ID', `user_name` varchar(64) NOT NULL COMMENT 'User name', `email` varchar(64) NOT NULL COMMENT 'E-Mail address', `password` varchar(256) COLLATE utf8mb4_bin DEFAULT NULL COMMENT 'password', `status` INT DEFAULT 0 COMMENT 'User status: 0-inactive; 1-active', `created_time` datetime DEFAULT NULL COMMENT 'created time', `updated_time` datetime DEFAULT NULL COMMENT 'updated time', PRIMARY KEY (`user_id`), UNIQUE KEY `t_user_unique_key` (`user_name`, `email`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE utf8mb4_general_ci; 编写相应的 Entity123456789101112131415161718192021222324252627public class UserEntity { @Id @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;) @GeneratedValue(generator = &quot;idGenerator&quot;) @Column(name = &quot;user_id&quot;, length = 32, nullable = false) private String id; @Column(name = &quot;user_name&quot;, columnDefinition = &quot;VARCHAR(64) NOT NULL COMMENT 'user name'&quot;) private String username; @Column(name = &quot;email&quot;, columnDefinition = &quot;VARCHAR(64) NOT NULL COMMENT 'email'&quot;) private String email; @Column(name = &quot;password&quot;, columnDefinition = &quot;VARCHAR(256) COLLATE utf8mb4_bin DEFAULT NULL comment 'password'&quot;) private String password; @Column(name = &quot;status&quot;, columnDefinition = &quot;INT NOT NULL DEFAULT 0 COMMENT '0:inactive 1:active'&quot;) private Integer status; @Column(name = &quot;created_time&quot;) @CreationTimestamp private LocalDateTime createdAt; @Column(name = &quot;updated_time&quot;) @UpdateTimestamp private LocalDateTime updatedAt;} 测试1234567891011121314151617@SpringBootTestpublic class UserEntityTest { UserRepository userRepository; @Autowired public UserEntityTest(UserRepository userRepository) { this.userRepository = userRepository; } @Test public void test(){ UserEntity userEntity = new UserEntity(); userEntity.setUsername(&quot;Jackson&quot;); userEntity.setEmail(&quot;Jackson@email.com&quot;); userEntity.setStatus(0); userEntity.setPassword(&quot;password&quot;); userRepository.save(userEntity); }} 总结麻烦了一点，但是对于数据还是需要慎重一些","link":"/2022/03/23/JPA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"title":"JPA使用记录-配置","text":"概述记录如何使用 JPA build.gradle 配置123456789101112131415161718192021222324252627282930313233plugins { id 'org.springframework.boot' version '2.6.4' id 'io.spring.dependency-management' version '1.0.11.RELEASE' id 'java'}group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '1.8'configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' implementation 'org.springframework.boot:spring-boot-starter-validation' implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' runtimeOnly 'mysql:mysql-connector-java' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test'}tasks.named('test') { useJUnitPlatform()} 项目配置首先将项目配置为多个不同环境 application.yaml 配置 123spring: profiles: active: dev application-dev.yaml 配置 12345678910111213141516171819202122232425server: port: 8099spring: datasource: url: jdbc:mysql://127.0.0.1:3306/atp?useUnicode=true&amp;characterEncoding=utf-8 username: root password: qwe123 driver-class-name: com.mysql.cj.jdbc.Driver hikari: minimum-idle: 5 # 最小空闲时间 idle-timeout: 600000 # 空闲连接存活最大时间，默认是 60 00 00 ，也就是 10 分钟 maximum-pool-size: 10 #连接池最大连接数 默认是 10 auto-commit: true # 自动提交 max-lifetime: 1800000 # 连接池连接的最大生命周期 connection-timeout: 30000 # 连接查实的时间 默认 30 秒 jpa: hibernate: ddl-auto: update connection: provider_class: com.zaxxer.hikari.hibernate.HikariConnectionProvider show-sql: true database: mysql properties: hibernate: dialect: org.hibernate.dialect.MySQL5InnoDBDialect 代码新建一个实体类， 这个类会自动创建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import lombok.Getter;import lombok.Setter;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.GenericGenerator;import org.hibernate.annotations.UpdateTimestamp;import javax.persistence.*;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotEmpty;import java.time.LocalDateTime;/** * CREATE TABLE IF NOT EXISTS `t_project`( * `project_id` bigint auto_increment primary key comment '主键', * `project_name` varchar(50) not null comment '项目名称', * `project_owner` varchar(50) not null comment '项目owner', * `project_desc` varchar(250) comment '项目描述', * `created_time` datetime not null comment '创建时间', * `updated_time` datetime not null comment '更新时间' * )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; */@Table(name = &quot;t_project&quot;)@Getter@Setter@Entitypublic class Project { @Id @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;) @GeneratedValue(generator = &quot;idGenerator&quot;) @Column(name = &quot;project_id&quot;, length = 32) private String projectId; @Column(name = &quot;project_name&quot;, columnDefinition = &quot;VARCHAR(50) NOT NULL COMMENT '项目名称'&quot;) @NotBlank(message = &quot;project name can't be null! &quot;) @NotEmpty(message = &quot;project name can't be null! &quot;) public String projectName; @Column(name = &quot;project_owner&quot;, columnDefinition = &quot;varchar(50) not null comment '项目owner'&quot;) @NotBlank(message = &quot;project owner can't be null&quot;) @NotEmpty(message = &quot;project owner can't be null! &quot;) public String projectOwner; @Column(name = &quot;project_desc&quot;, columnDefinition = &quot;varchar(250) comment '项目描述'&quot;) public String projectDesc; /** * 自动添加创建时间 */ @Column(name = &quot;created_time&quot;) @CreationTimestamp public LocalDateTime createdAt; /** * 自动添加更新时间 */ @Column(name = &quot;updated_time&quot;) @UpdateTimestamp public LocalDateTime updatedAt;} 然后创建一个 repository 类来执行 sql 操作 12345import com.chancetop.atp.entites.Project;import org.springframework.data.repository.CrudRepository;public interface ProjectRepository extends CrudRepository&lt;Project, String&gt;{} 最后我们写一个测试类， 来测试下是否正常 123456789101112131415161718@SpringBootTestpublic class ProjectTest { private ProjectRepository projectRepository; @Autowired public ProjectTest(ProjectRepository projectRepository){ this.projectRepository = projectRepository; } @Test public void testSave(){ Project project = new Project(); project.setProjectName(&quot;test-project&quot;); project.setProjectOwner(&quot;jackson&quot;); project.setProjectDesc(&quot;this is test project&quot;); projectRepository.save(project); }}","link":"/2022/03/22/JPA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-%E9%85%8D%E7%BD%AE/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/23/hello-world/"},{"title":"使用docker-compose启动kafaka","text":"概述为了学习如何在 springboot 中使用 kafaka. 因此需要简单记录一下搭建过程。 搭建过程使用以下配置文件， 即可自启动 kafaka 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748---version: '2'services: zookeeper-1: image: confluentinc/cp-zookeeper:latest environment: ZOOKEEPER_CLIENT_PORT: 2181 ZOOKEEPER_TICK_TIME: 2000 ports: - 22181:2181 zookeeper-2: image: confluentinc/cp-zookeeper:latest environment: ZOOKEEPER_CLIENT_PORT: 2181 ZOOKEEPER_TICK_TIME: 2000 ports: - 32181:2181 kafka-1: image: confluentinc/cp-kafka:latest depends_on: - zookeeper-1 - zookeeper-2 ports: - 29092:29092 environment: KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper-1:2181,zookeeper-2:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka-1:9092,PLAINTEXT_HOST://localhost:29092 KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1 kafka-2: image: confluentinc/cp-kafka:latest depends_on: - zookeeper-1 - zookeeper-2 ports: - 39092:39092 environment: KAFKA_BROKER_ID: 2 KAFKA_ZOOKEEPER_CONNECT: zookeeper-1:2181,zookeeper-2:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka-2:9092,PLAINTEXT_HOST://localhost:39092 KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1 安装 kafaka tool 来连接 kafaka. 首先取个名字: 然后配置一下地址即可","link":"/2022/03/23/%E4%BD%BF%E7%94%A8docker-compose%E5%90%AF%E5%8A%A8kafaka/"}],"tags":[{"name":"JMeter","slug":"JMeter","link":"/tags/JMeter/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"}],"categories":[]}